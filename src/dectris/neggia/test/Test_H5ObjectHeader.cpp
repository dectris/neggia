// SPDX-License-Identifier: MIT

#include <dectris/neggia/data/H5ObjectHeader.h>
#include <dectris/neggia/data/JenkinsLookup3Checksum.h>
#include <gtest/gtest.h>

TEST(TestH5ObjectHeaderV1, CanBeParsed) {
    // see "Version 1 Object Header"
    // https://support.hdfgroup.org/HDF5/doc/H5.format.html#ObjectHeader
    // clang-format off
    const unsigned char data[280] = {
        0x01, 0x00, 0x06, 0x00, // version 1, number of messages 6
        0x01, 0x00, 0x00, 0x00,
        0x08, 0x01, 0x00, 0x00, // block size 264
        0x00, 0x00, 0x00, 0x00, // padding for 8-byte alignment of messages
        0x01, 0x00, 0x38, 0x00, // header [message type 0x0001, size 56]
        0x00, 0x00, 0x00, 0x00,
        0x01, 0x03, 0x01, 0x00, // message data
        0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x0d, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x0b, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0x0d, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x0b, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x10, 0x00, // header [message type 0x0003, size 16]
        0x01, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, // message data
        0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x08, 0x00, // header [message type 0x0005, size 8]
        0x01, 0x00, 0x00, 0x00,
        0x02, 0x03, 0x02, 0x01, // message data
        0x00, 0x00, 0x00, 0x00,
        0x0b, 0x00, 0x60, 0x00, // header [message type 0x000b, size 96]
        0x01, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x00, 0x00, // message data
        0x00, 0x00, 0x00, 0x00,
        0x04, 0x7d, 0x50, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x48, 0x44, 0x46, 0x35,
        0x20, 0x6c, 0x7a, 0x34,
        0x20, 0x66, 0x69, 0x6c,
        0x74, 0x65, 0x72, 0x3b,
        0x20, 0x73, 0x65, 0x65,
        0x20, 0x68, 0x74, 0x74,
        0x70, 0x3a, 0x2f, 0x2f,
        0x77, 0x77, 0x77, 0x2e,
        0x68, 0x64, 0x66, 0x67,
        0x72, 0x6f, 0x75, 0x70,
        0x2e, 0x6f, 0x72, 0x67,
        0x2f, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65,
        0x73, 0x2f, 0x63, 0x6f,
        0x6e, 0x74, 0x72, 0x69,
        0x62, 0x75, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e,
        0x68, 0x74, 0x6d, 0x6c,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x20, 0x00, // header [message type 0x0008, size 32]
        0x01, 0x00, 0x00, 0x00,
        0x03, 0x02, 0x04, 0x90, // message data
        0x0d, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x0d,
        0x00, 0x00, 0x00, 0x0b,
        0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x12, 0x00, 0x08, 0x00, // header [message type 0x0012, size 8]
        0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, // message data
        0x73, 0xfe, 0x3d, 0x60,
    };
    // clang-format on
    const std::vector<uint16_t> messageTypes{0x1, 0x3, 0x5, 0xb, 0x8, 0x12};
    const std::vector<size_t> messageOffsets{24, 88, 112, 128, 232, 272};
    const auto msg = H5ObjectHeader((const char*)data, 0);
    ASSERT_EQ(msg.version(), 1);
    ASSERT_EQ(msg.numberOfMessages(), 6);
    for (int i = 0; i < 6; i++) {
        EXPECT_EQ(msg.headerMessage(i).type, messageTypes[i]);
        EXPECT_EQ(msg.headerMessage(i).object.offset(), messageOffsets[i]);
    }
}

TEST(TestH5ObjectHeaderV2, CanBeParsed) {
    // see "Version 2 Object Header"
    // https://support.hdfgroup.org/HDF5/doc/H5.format.html#ObjectHeader
    // clang-format off
    const unsigned char data[147] = {
        0x4f, 0x48, 0x44, 0x52, // signature "OHDR"
        0x02, 0x20,             // version 2, flags 0x20
        0x64, 0x17, 0x18, 0x60,
        0x64, 0x17, 0x18, 0x60,
        0x64, 0x17, 0x18, 0x60,
        0x64, 0x17, 0x18, 0x60,
        0x78,                   // size of chunk #0 120
        0x02, 0x12, 0x00, 0x00, // message 0x02, size 18
        0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff,
        0x0a, 0x02, 0x00, 0x01, // message 0x0a, size 2
        0x00, 0x00,
        0x15, 0x12, 0x00, 0x04, // message 0x15, size 18
        0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff,
        0x0c, 0x25, 0x00, 0x00, // message 0x0c, size 37
        0x03, 0x00, 0x09, 0x00,
        0x08, 0x00, 0x04, 0x00,
        0x00, 0x4e, 0x58, 0x5f,
        0x63, 0x6c, 0x61, 0x73,
        0x73, 0x00, 0x13, 0x00,
        0x00, 0x00, 0x07, 0x00,
        0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x4e, 0x58,
        0x64, 0x61, 0x74, 0x61,
        0x00,
        0x06, 0x0f, 0x00, 0x00, // message 0x06, size 15
        0x01, 0x00, 0x04, 0x64,
        0x61, 0x74, 0x61, 0xe9,
        0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x00, // message 0x00, size 6
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0xc0, 0x17, 0xef, 0xbd, // 4-byte Jenkins checksum
    };
    // clang-format on
    const auto msg = H5ObjectHeader((const char*)data, 0);
    ASSERT_EQ(msg.version(), 2);
    ASSERT_EQ(msg.numberOfMessages(), 6);
    const uint32_t checkSumCalculated = JenkinsLookup3Checksum(
            std::string((const char*)data, sizeof(data) - 4));
    const uint32_t checkSumFromData = *(uint32_t*)&data[sizeof(data) - 4];
    ASSERT_EQ(checkSumCalculated, checkSumFromData);
    const std::vector<uint16_t> messageTypes{0x2, 0xa, 0x15, 0xc, 0x6, 0x0};
    const std::vector<size_t> messageOffsets{27, 49, 55, 77, 118, 137};
    for (int i = 0; i < 6; i++) {
        EXPECT_EQ(msg.headerMessage(i).type, messageTypes[i]);
        EXPECT_EQ(msg.headerMessage(i).object.offset(), messageOffsets[i]);
    }
}
